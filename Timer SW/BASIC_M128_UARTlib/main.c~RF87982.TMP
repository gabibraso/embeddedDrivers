/*
* main.c
*
* Created: 22.05.2018
* Author : Bogdan Tarnauca
*/

//Applications must include an "main_config.h" header where libraries related params, overrides, settings should be defined.
//This includes F_CPU, the target, compiler, libs.
//This header file is application specific. Must be provided even if it is empty, all ABT AVR libs include it
#include "main_config.h"

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include<avr/wdt.h>
#include<avr/interrupt.h>

#include "main_defines.h"
	//Application related defines and variables

#include "avr_usart.h"
    //USART driver from the libabr_uart library
	
#include "main_func.h"
	//Application functions
	
#include "main_MCU_init.h"
	//MCU initialization (ports, UART, etc.)
int ledCurent = 0;
bool sensLed = true;
bool buttonpressed = false;	

int main(void)
{
mainCycleCount = 0;

//Initialize MCU
init_devices();

//Print reset source.
if(MCUCSR & 0x01)
    uart1_Transmite("\n\rPOWER ON!",11, true);
WDR();
if(MCUCSR & 0x02)
    uart1_Transmite("\n\rEXTERNAL!",11, true);
WDR();
if(MCUCSR & 0x04)
    uart1_Transmite("\n\rBROUN OUT!",12, true);
WDR();
if(MCUCSR & 0x08)
    uart1_Transmite("\n\rWATCH DOG!",12, true);
WDR();
if(MCUCSR & 0x10)
    uart1_Transmite("\n\rJTAG!",7, true);
WDR();
uart1_Transmite("\n\r",2, true);
MCUCSR = 0;

uart1_bReceptioneaza = false;

// Initializare porturi LED-uri
	DDRB  = 0xFF;
	PORTB = 0x00;
// Initializare porturi Butoane
	DDRE  = (0<<DDRE4) | (0<<DDRE5) | (0<<DDRE6);
	PORTE = (1<<PORTE4) | (1<<PORTE5) | (1<<PORTE6); 
// Setare pin intrerupere
	EICRB = (1<<ISC41) | (0<<ISC40) | (1<<ISC51) | (0<<ISC50) | (1<<ISC61) | (0<<ISC60);
	EIMSK = (1<<INT4) | (1<<INT5) |(1<<INT6);

// Setare timer debouncing
	TCCR3A = (0<<WGM11) | (0<<WGM10);									   //CTC
	TCCR3B = (1<<WGM13) | (1<<WGM12) | (1<<CS12) | (0<<CS11) | (0<<CS10);  //prescalar 256
	TIMSK |= (1<<TICIE3); //activare intrerupere
	ICR3 = 288; //max 28800 (0.5sec)
	
// Setare timer (Var 1 input capture)
	TCCR1A = (0<<WGM11) | (0<<WGM10);									   //CTC
	TCCR1B = (1<<WGM13) | (1<<WGM12) | (1<<CS12) | (0<<CS11) | (0<<CS10);  //prescalar 256
	TIMSK |= (1<<TICIE1); //activare intrerupere
	ICR1 = 14400; //max 28800 (0.5sec)

// Setare timer (Var 2 overflow)
//	TCCR1B = (1<<CS12) | (0<<CS11) | (0<<CS10); //prescalar 256
//	TCNT1 = 36735;								//valoare de la care incepe sa numere
//	TIMSK = (1<<TOIE1);							//activare intrerupere overflow

// Setare timer (Var 3 output compare)
	//TCCR1A = (0<<WGM11) | (0<<WGM10); //set mod CTC
	//TCCR1B = (0<<WGM13) | (1<<WGM12) | (1<<CS12) | (0<<CS11) | (0<<CS10); //prescalar 256
	//TCNT1 = 0;				//initializare counter 0				
	//OCR1A = 28800;			//valoarea de comparat									
	//TIMSK = (1<<OCIE1A);	//activare intrerupere 
	sei();
	
do
{
    //Reset watchdog to prevent a reset
    wdt_reset(); 
    
    //If there is no pending UART operation start listening
	if(!uart1_bReceptioneaza && !uart1_bTransmite && !uart1_bStareNeprocesata)
	{
       //Listen for characters until the terminal character is received 
       //(carriage return in this case) or the maximum number of chars 
       //is received (to prevent buffer over flow)
       //Received data is stored in the snTelegramaRx input buffer.
       //The input buffer is reset (index set to 0) before Rx is initiated
       //Once the terminal char is received, receiving further characters
       //is blocked. Any other chars will be discarded
       uart1_ReceptieTermTX(snTelegramaRx, RX_TERM, L_BUF_RX, true, true);	   	  	          
    } 

    
    //Periodically evaluate the status of a message Rx
    //Checking the Rx complete condition in a non-ISR function is meant to keep 
    //the ISR as short as possible.
    uart1_ReceptieOK();
    wdt_reset(); 

    //Check if the UART unprocessed flag has been set
    if(uart1_bStareNeprocesata)
	{   
	    //An TxOK, RxOK, Timeout of BufferLimit condition has been detected
        //We don't test for timeout as we have configured the UART in slave mode

        if(uart1_bRXBufferLimit)
        {
            //ToDo: Do some error processing for buffer limit.            
            //Reset the uart flags
            uart1_bReceptioneaza = false;
            uart1_bRXBufferLimit = false;
            uart1_nContorRX = 0;
            uart1_bStareNeprocesata = false;
			uart1_bRxOK = false;
            wdt_reset(); 
        }
	   
       if(uart1_bRxOK)
        {
            //Copy the received data from the Rx buffer into the Tx buffer
            //and send the echo.
            memcpy(snTelegramaTx, snTelegramaRx, uart1_nLungimeRX);
            //add new line and carriage return
            memcpy(snTelegramaTx + uart1_nLungimeRX, sNewLine, 3);
            
            //Commence the transmission
            //If a transmission is already ongoing block here until that is finished
            //and then set the current transmission.
            //Note that the transmission function is otherwise not blocking.
			uart1_TransmiteExt(snTelegramaTx , strlen(snTelegramaTx), true, false);						
        }
        
        //reset the flag to prevent re-processing of the same conditions 
        uart1_bStareNeprocesata = false; 
	}
 
}
while(1);
}


//ISR(TIMER1_OVF_vect) //overflow
//{
	//TCNT1 = 36735;
	//if(sensLed)
		//{
			//PORTB = (1<< ledCurent);
			//if(ledCurent > 6)
			//ledCurent = 0;
			//else
			//ledCurent++;
		//}else
		//{
			//PORTB = (1<< ledCurent);
			//if(ledCurent < 1)
			//ledCurent = 7;
			//else
			//ledCurent--;
		//}
//}

//ISR(TIMER1_COMPA_vect) //output compare
//{
	//if(sensLed)
	//{
		//PORTB = (1<< ledCurent);
		//if(ledCurent > 6)
		//ledCurent = 0;
		//else
		//ledCurent++;
	//}else
	//{
		//PORTB = (1<< ledCurent);
		//if(ledCurent < 1)
		//ledCurent = 7;
		//else
		//ledCurent--;
	//}
//}

ISR(TIMER1_CAPT_vect) //input capture
{
	if(sensLed)
	{
		PORTB = (1<< ledCurent);
		if(ledCurent > 6)
		ledCurent = 0;
		else
		ledCurent++;
	}else
	{
		PORTB = (1<< ledCurent);
		if(ledCurent < 1)
		ledCurent = 7;
		else
		ledCurent--;
	}
}

ISR(TIMER3_CAPT_vect)
{
	if((PINE & (1<<PINE6)) = 0)
	{
		if(buttonpressed)
			uart1_Transmite("\n\rPOWER ON!",11, true);
	}
	uart1_Transmite("\n\rPOWER OFF!",12, true);
	
	TCCR3B = (0<<CS12) | (0<<CS11) | (0<<CS10);
	
}

ISR(INT4_vect)
{
	TCNT1 = 0;
	sensLed = !sensLed;
	buttonpressed = true;
}

ISR(INT5_vect)
{
	TCNT1 = 0;
	ICR1 = 28800; //1sec
	//OCR1A = 28800;
}

ISR(INT6_vect)
{
	TCNT1 = 0;
	ICR1 = 2880;  //0.1sec
	//OCR1A = 2880;
}